generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id @default(uuid())
  email         String?   @unique
  name          String?
  image         String?
  emailVerified DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts  Account[]
  sessions  Session[]
  wallets   Wallet[]
  balances  Balance[]
  deposits  Deposit[]
  withdrawals Withdrawal[]
  positions Position[]
  trades    Trade[]
}

model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

enum Chain {
  ethereum
  arbitrum
  solana
}

model Wallet {
  id        String   @id @default(uuid())
  userId    String
  chain     Chain
  address   String
  isPrimary Boolean  @default(false)
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, chain])
  @@index([address])
}

enum AssetType {
  stable
}

model Asset {
  id            String    @id @default(uuid())
  symbol        String    @unique
  name          String
  type          AssetType
  decimals      Int
  chain         Chain
  contractAddress String?
  createdAt     DateTime  @default(now())

  balances Balance[]
  deposits Deposit[]
  withdrawals Withdrawal[]
}

model Balance {
  id        String   @id @default(uuid())
  userId    String
  assetId   String
  available String   @default("0") // Store as string to avoid precision issues
  locked    String   @default("0")
  updatedAt DateTime @updatedAt

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  asset Asset @relation(fields: [assetId], references: [id])

  @@unique([userId, assetId])
}

enum MarketType {
  perp
}

enum Venue {
  ostium
}

model Market {
  id          String     @id @default(uuid())
  type        MarketType
  venue       Venue
  chain       Chain
  symbol      String     @unique // e.g., "NVDA-PERP"
  baseSymbol  String     // e.g., "NVDA"
  quoteSymbol String     // e.g., "USD"
  name        String     // e.g., "NVIDIA"
  leverageMax Int
  venueSymbol String     // Ostium's canonical symbol
  isActive    Boolean    @default(true)
  createdAt   DateTime   @default(now())

  positions Position[]
  trades    Trade[]
}

enum DepositStatus {
  pending
  confirmed
  failed
}

model Deposit {
  id              String        @id @default(uuid())
  userId          String
  assetId         String
  chain           Chain
  amount          String
  txHash          String
  fromAddress     String
  toAddress       String
  confirmations   Int           @default(0)
  requiredConfirmations Int     @default(12)
  status          DepositStatus @default(pending)
  createdAt       DateTime      @default(now())
  confirmedAt     DateTime?

  user  User  @relation(fields: [userId], references: [id])
  asset Asset @relation(fields: [assetId], references: [id])

  @@index([txHash])
  @@index([status])
}

enum WithdrawalStatus {
  pending
  processing
  completed
  failed
}

model Withdrawal {
  id          String           @id @default(uuid())
  userId      String
  assetId     String
  chain       Chain
  amount      String
  toAddress   String
  txHash      String?
  status      WithdrawalStatus @default(pending)
  createdAt   DateTime         @default(now())
  processedAt DateTime?

  user  User  @relation(fields: [userId], references: [id])
  asset Asset @relation(fields: [assetId], references: [id])

  @@index([status])
}

enum PositionSide {
  long
  short
}

enum PositionStatus {
  open
  closed
  liquidated
}

model Position {
  id              String         @id @default(uuid())
  userId          String
  marketId        String
  side            PositionSide
  leverage        Int
  entryPrice      String
  currentPrice    String
  size            String         // Position size in USD
  margin          String         // Collateral in USD
  unrealizedPnl   String         @default("0")
  realizedPnl     String         @default("0")
  fundingPaid     String         @default("0")
  status          PositionStatus @default(open)
  openTxHash      String?
  closeTxHash     String?
  liquidationPrice String?
  createdAt       DateTime       @default(now())
  closedAt        DateTime?

  user   User   @relation(fields: [userId], references: [id])
  market Market @relation(fields: [marketId], references: [id])
  trades Trade[]

  @@index([userId, status])
}

enum TradeType {
  open
  close
  liquidation
}

model Trade {
  id         String    @id @default(uuid())
  userId     String
  positionId String
  marketId   String
  type       TradeType
  side       PositionSide
  price      String
  size       String
  fee        String    @default("0")
  txHash     String?
  createdAt  DateTime  @default(now())

  user     User     @relation(fields: [userId], references: [id])
  position Position @relation(fields: [positionId], references: [id])
  market   Market   @relation(fields: [marketId], references: [id])

  @@index([userId])
  @@index([positionId])
}
